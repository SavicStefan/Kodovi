// AhoCorasick: https://codeforces.com/contest/79/submission/92018946
// Hash
const int p = 31 // za mala slova
const int p = 53 // za velika slova
const int mod = 1e9 + 9; // sad cu probati da li moze 1e9 + 7;
int hsh[maxn];
void hes(string a){
   ll pw = 1;
   ff(i,1,sz(a)){
      hsh[i] = add(hsh[i - 1], mul(pw, s[i] - 'a' + 1));
      pw = mul(pw, p);
   }
}

int hes(string a){
    ll pw = 1;
    int hes = 0;
    ff(i,1,sz(a)){
        hes = add(hes, mul(pw, a[i] - 'a' + 1));
        pw = mul(pw, p);
    }
    return hes;
}

// Rabin-Karp - hesh 

// Suffix Array - O(n log^2 n)
vector<int> buildSuffixArray(string a){
	a += '$';
	int N = sz(a);
	vector<int> p(N);
	vector<int> sa(N);
	vector<pair<pii,int>> pomsa(N);
	{
		ff(i,0,N - 1)pomsa[i] = {{a[i] - 'a', 0}, i};
		sort(all(pomsa));
		p[pomsa[0].se] = 0;
		ff(i,1,N - 1){
			if(pomsa[i].fi == pomsa[i - 1].fi)p[pomsa[i].se] = p[pomsa[i - 1].se];
			else p[pomsa[i].se] = p[pomsa[i - 1].se] + 1;
		}
		ff(i,0,N - 1)sa[i] = pomsa[i].se;
	}
	int k = 1;
	while((1 << k) <= N){
		ff(i,0,N - 1)pomsa[i] = {{p[i], p[(i + (1 << (k - 1))) % N]}, i};
		sort(all(pomsa));
		p[pomsa[0].se] = 0;
		ff(i,1,N - 1){
			if(pomsa[i].fi == pomsa[i - 1].fi)p[pomsa[i].se] = p[pomsa[i - 1].se];
			else p[pomsa[i].se] = p[pomsa[i - 1].se] + 1;
		}
		ff(i,0,N - 1)sa[i] = pomsa[i].se;
		k += 1;
	}
	return sa;
}

// Za O(n log n) - SuffixArray
void radix_sort(vector<pair<pii,int>> &a){
	int N = sz(a);
	{
		vector<int> cnt(N);
		for(auto c : a)cnt[c.fi.se] += 1;
		vector<pair<pii,int>> nwa(N);
		vector<int> pos(N);
		pos[0] = 0;
		ff(i,1,N - 1)pos[i] = pos[i - 1] + cnt[i - 1];
		for(auto c : a){
			int id = c.fi.se;
			nwa[pos[id]] = c;
			pos[id] += 1;
		}
		a = nwa;
	}
	{
		vector<int> cnt(N);
		for(auto c : a)cnt[c.fi.fi] += 1;
		vector<pair<pii,int>> nwa(N);
		vector<int> pos(N);
		pos[0] = 0;
		ff(i,1,N - 1)pos[i] = pos[i - 1] + cnt[i - 1];
		for(auto c : a){
			int id = c.fi.fi;
			nwa[pos[id]] = c;
			pos[id] += 1;
		}
		a = nwa;
	}
}

// Manacher - najveci palindrom (tehnicki)
void Manacher(string a){
	int N = sz(a);
	vector<int> d1(N);
	int L = 0, R = -1;
	ff(i,0,N - 1){
		int k = (i > R ? 1 : min(d1[L + R - i], R - i + 1));
		while(i >= k && i + k < N && a[i - k] == a[i + k])k += 1;
		d1[i] = k--;
		if(i + k > R){
			L = i - k;
			R = i + k;
		}
	}
	vector<int> d2(N);
	L = 0, R = -1;
	ff(i,0,N - 1){
		int k = (i > R ? 0 : min(d2[L + R - i + 1], R - i + 1));
		while(i > k && i + k < N  && a[i - k - 1] == a[i + k])k += 1;
		d2[i] = k--;
		if(i + k > R){
			L = i - k - 1;
			R = i + k;	
		}
	}
}
