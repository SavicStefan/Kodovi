Graph admits an orientation to a strongly connected digraph if and only if every edge is part of what a cycle.

//DFS:
void dfs(int v){
	visited[v] = 1;
	for(auto u : g[v]){
    	if(!visited[u]){
    		dfs(u);
      }
   }
}


//BFS:
int d[maxn];
bool used[maxn];
void bfs(int s){
   used[s] = 1;
   d[s] = 0;
   queue<int> q;
   q.push(s);
   while(!q.empty()){
      int v = q.front();
      q.pop();
      for(auto u : g[v]){
         if(!used[u]){
            used[u] = 1;
            d[u] = d[v] + 1;
            q.push(u);
         }
      }
   }
}


//Dijstrik - using pq
ll dist[maxn];
void dij(int sv){
    ff(i,1,n)dist[i] = inf;
    priority_queue<pii> pq;
    pq.push({dist[sv] = 0, sv});
    while(!pq.empty()){
        pii v = pq.top();pq.pop();
        if(dist[v.se] < -v.fi)continue;
        for(auto c : g[v.se]){
            int u = c.fi;
            int w = c.se;
            if(dist[u] > w + -v.fi){
                dist[u] = -v.fi + w;
                pq.push({-dist[u], u});
            }
        }
    }
}


//Dijstrik - using set
ll dist[maxn];
void dij(ll sv){
    ff(i,1,n)dist[i] = inf;
    set<pii> s;
    s.insert({dist[sv] = 0, sv});
    while(!s.empty()){
        auto v = s.begin()->second;
        s.erase(s.begin());
        for(auto c : g[v]){
            ll u = c.first;
            ll w = c.second;
            if(dist[v] + w < dist[u]){
                s.erase({dist[u], u});
                dist[u] = dist[v] + w;
                s.insert({dist[u], u});
            }
        }
    }
}



//MST - Kruskal
struct grana{
   int a, b, c;
};
vector<grana> drvo;
bool cmp(grana s1, grana s2){
   return s1.c < s2.c;
}
void mst(){
   sort(all(drvo), cmp);
   for(auto c : drvo){
      int u = c.a;
      int v = c.b;
      int w = c.c;
      if(findpar(u) != findpar(v)){
         unite(u,v);
         e[u].pb({v,w});
         e[v].pb({u,w});
      }
   }
}


//Shortest cycle(mora for za svaki node, za koji hocemo)
int d[maxn], rod[maxn];
int rez = 1e9;
void min_cycle(int s){
    for(auto c : v){
        d[c] = 1e9;
        rod[c] = -1;
    }
    d[s] = 0;
    queue<int> q;
    q.push(s);
    while(!q.empty()){
        int v = q.front();
        q.pop();
        for(auto u:g[v]){
            if(d[u] == 1e9){
                d[u] = d[v] + 1;
                rod[u] = v;
                q.push(u);
            }
            else{
                if(rod[v] != u && rod[u] != v)
                    rez = min(rez, d[v] + d[u] + 1);
            }
        }
    }
}



//Detect if given undirected graph have a cycle
bool krug = 0;
bool visited[maxn];
void dfs(int v, int p){
    visited[v] = 1;
    for(auto u : g[v]){
        if(!visited[u])dfs(u, v);
        else krug |= (u != p);
    }
}


// Find cycle in undirected graph
vector<int> krug;
int par[maxn];
bool visited[maxn];
void dfs(int v, int p){
    visited[v] = 1;
    par[v] = p;
    for(auto u : g[v]){
        if(!visited[u])dfs(u, v);
        else{
            if(u != p){
                int a = v;
                while(a != u){
                    krug.pb(a);
                    a = par[a];
                }
                krug.pb(u);
                krug.pb(v);
                cout << krug.size() << endl;
                for(auto c : krug)cout << c << " ";
                cout << endl;
                exit(0);
            }
        }
    }
}


//Detect if given directed graph have a cycle - if you have back edges then you have cycle
bool krug = 0;
int was[maxn];
void dfs(int v){
    was[v] = 1;
    for(auto u : g[v]){
        if(!was[u])dfs(u);
        else krug |= (was[u] == 1);
    }
    was[v] = 2;
}
`


// Find cycle in directed graph
vector<int> krug;
int was[maxn];
int par[maxn];
void dfs(int v, int p){
    was[v] = 1;
    par[v] = p;
    for(auto u : g[v]){
        if(!was[u])dfs(u, v);
        else{
            if(was[u] == 1){
                int a = v;
                while(a != u){
                    krug.pb(a);
                    a = par[a];
                }
                krug.pb(u);
                krug.pb(v);
                reverse(all(krug));
                cout << krug.size() << endl;
                for(auto c : krug)cout << c << " ";
                cout << endl;
                exit(0);
            }
        }
    }
    was[v] = 2;
}


// Topological sorting
vector<int> topo;
int indeg[maxn];
void toposort(){
    queue<int> q;
    ff(i,1,n){
        if(!indeg[i])q.push(i);
    }
    while(!q.empty()){
        int v = q.front();q.pop();
        topo.pb(v);
        for(auto u : g[v]){
            indeg[u]--;
            if(!indeg[u])q.push(u);
        }
    }
}


//Kosaraju - SCC - with two graph 
vector<int> todo;
bool visited[maxn];
void dfs1(int v){
    visited[v] = 1;
    for(auto u : g[v]){
        if(!visited[u])dfs1(u);
    }
    todo.pb(v);
}
int comp[maxn];
void dfs2(int v, int clr){
    comp[v] = clr;
    for(auto u : e[v]){
        if(!comp[u])dfs2(u, clr);
    }
}
vector<int> all;
void kosaraju(){
    ff(i,1,n){
        visited[i] = 0;
        comp[i] = 0;
    }
    ff(i,1,n){
        if(visited[i])continue;
        dfs1(i);
    }
    reverse(all(todo));
    for(auto c : todo){
        if(comp[c] == 0){
            dfs2(c, c);
            all.pb(c);
        }
    }
}

//Kosaraju - SCC - with one graph with weight for direction
vector<int> todo;
bool visited[maxn];
void dfs1(int v){
    visited[v] = 1;
    for(auto c : g[v]){
        int u = c.fi;
        int w = c.se;
        if(w == -1)continue;
        if(!visited[u])dfs1(u);
    }
    todo.pb(v);
}
int comp[maxn];
void dfs2(int v, int clr){
    comp[v] = clr;
    for(auto c : g[v]){
        int u = c.fi;
        int w = c.se;
        if(w == 1)continue;
        if(!comp[u])dfs2(u, clr);
    }
}
vector<int> all;
void kosaraju(){
    ff(i,1,n){
        visited[i] = 0;
        comp[i] = 0;
    }
    ff(i,1,n){
        if(visited[i])continue;
        dfs1(i);
    }
    reverse(all(todo));
    for(auto c : todo){
        if(comp[c] == 0){
            dfs2(c, c);
            all.pb(c);
        }
    }
}

// Euler walk for undireceted graph
bool bad = 0;
bool bioe[maxn];
vector<pii> circuit;
void dfs(int p, int v){
    while(!g[v].empty()){
        pii u = g[v].back();g[v].pop_back();
        if(bioe[u.se])continue;
        bioe[u.se] = 1;
        dfs(v, u.fi);
    }
    if((int)circuit.size() && circuit.back().fi != v)bad = 1;
    circuit.pb({p, v});
}
vector<int> euler_seta(int s){
    circuit.clear();
    bad = 0;
    ff(i,1,m)bioe[i] = 0;
    ff(i,1,n)if(deg[i] % 2 == 1)return {};
    dfs(-1, s);
    int len = (int)circuit.size();
    if(len != m + 1 || bad)return {};
    vector<int> ans;
    fb(i,len - 1, 0)ans.pb(circuit[i].se);
    return ans;
}

// Euler walk for directed graph



//LCA
int timer = 0;
ll d[maxn];
int in[maxn];
int out[maxn];
int deda[maxn][20];
void dfs(int v, int p){
    deda[v][0] = p;
    ff(i,1,19)deda[v][i] = deda[deda[v][i - 1]][i - 1];
    in[v] = ++timer;
    for(auto u : g[v]){
        if(u != p){
            d[u] = d[v] + 1;
            dfs(u, v);
        }
    }
    out[v] = timer;
}
bool predak(int u, int v){
    return (in[u] <= in[v] && out[u] >= out[v]);
}
int lca(int u, int v){
    if(predak(u, v))return u;
    if(predak(u, v))return v;
    for(int i=19;i>=0;i--){
        if(deda[u][i] && !predak(deda[u][i], v))u = deda[u][i];
    }
    return deda[u][0];
}
int dist(int u, int v){
    return d[u] + d[v] - 2 * d[lca(u, v)];
}


//Centroid decomposition (Each subtree in the centroid tree forms a connected component in the original tree)

int cnt[maxn];
bool bio[maxn];
void dfs_size(int v, int p){
    cnt[v] = 1;
    for(auto u : g[v]){
        if(u == p || bio[u])continue;
        dfs_size(u, v);
        cnt[v] += cnt[u];
    }
}
int centroid(int v, int p, int vel){
    for(auto u : g[v]){
        if(u == p || bio[u])continue;
        if(cnt[u] > vel / 2)return centroid(u, v, vel);
    }
    return v;
}
void decompose(int v, int p){
    dfs_size(v, p);
    int cen = centroid(v, p, cnt[v]);
    bio[cen] = 1;
    for(auto u : g[cen]){
        if(u == p || bio[u])continue;
        decompose(u, cen);
    }
}


// Euler tour magic - for query on path (u, v)

int n, q;
int niz[maxn];

vector<int> g[maxn];

int a[maxn];

int tin[maxn];
int tout[maxn];
int timer = 0;
void dfs(int v, int p){
    tin[v] = ++timer;
    for(auto u : g[v]){
        if(u != p)dfs(u, v);
    }
    tout[v] = ++timer;
}

ll dud[maxn];
void upd(int x, ll val){
    while(x <= maxn){
        dud[x] += val;
        x += x&(-x);
    }
}
ll query(int x){
    ll sum = 0;
    while(x > 0){
        sum += dud[x];
        x -= x&(-x);
    }
    return sum;
}

int main()
{
    ios::sync_with_stdio(false);
    cout.tie(nullptr);
    cin.tie(nullptr);
    cin >> n;
    ff(i,1,n)cin >> niz[i];
    ff(i,1,n - 1){
        int u, v;
        cin >> u >> v;
        g[u].pb(v);
        g[v].pb(u);
    }
    cout << endl;
    dfs(1, -1);
    ff(i,1,n)upd(tin[i], niz[i]);
    cin >> q;
    while(q--){
        int t;
        cin >> t;
        if(t == 1){
            int x, val;
            cin >> x >> val;
            upd(tin[x], val);
            upd(tout[x], -val);
        }
        if(t == 2){
            int x;
            cin >> x;
            cout << query(tin[x]) << endl;
        }
    }
    return 0;
}


// Cika Flojd
ll dist[maxn][maxn];
void flojd(){
    ff(i,1,n){
        ff(j,1,n)dist[i][j] = inf;
    }
    ff(i,1,n)dist[i][i] = 0;
    for(auto c : grana)dist[c[0]][c[1]] = min(dist[c[0]][c[1]], c[2]);
    ff(k,1,n){
        ff(i,1,n){
            ff(j,1,n){
                if(dist[i][k] != inf && dist[k][j] != inf)dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }
}

// Cika Bellman - skontati kako radi
bool bad[maxn];
ll dist[maxn];

ll getDist(int x){
    return bad[x] ? -inf : dist[x];
}

void bellman(int s){
    ff(i,1,n){
        dist[i] = inf;
        bad[i] = 0;
    }
    dist[s] = 0;
    ff(i,0,n - 1){
        for(auto c : ed){
            if (dist[c[0]] < inf)dist[c[1]] = min(dist[c[1]], dist[c[0]] + c[2]);
        }
    }
    for(auto c : ed){
        if(dist[c[0]] < inf && dist[c[1]] > dist[c[0]] + c[2])bad[c[1]] = 1;
    }
    ff(i,0,n - 1){
        for(auto c : ed){
            if(bad[c[0]])bad[c[1]] = 1;
        }
    }
}

//Print cycle with negativ weight - cycle_with_negativ_weight.cpp
