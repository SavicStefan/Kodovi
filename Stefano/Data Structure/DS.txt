//DSU
int par[maxn], sz[maxn];
int findpar(int x){
    if(x == par[x])return x;
    return par[x] = findpar(par[x]);
}
void unite(int x, int y){
    int a = findpar(x);
    int b = findpar(y);
    if(a == b)return;
    if(sz[a] > sz[b]){
        par[a] = b;
        sz[b] += sz[a];
    }
    else{
        par[b] = a;
        sz[a] += sz[b];
    }
}
void init(){
    for(int i=1;i<=n;i++){
        par[i] = i;
        sz[i] = 1;
    }
}



//FENWIK TREE
ll dud[maxn];
void upd(int x, ll val){
    while(x <= maxn){
        dud[x] += val;
        x += x&(-x);
    }
}
ll query(int x){
    ll sum = 0;
    while(x > 0){
        sum += dud[x];
        x -= x&(-x);
    }
    return sum;
}



//Segment tree
ll bor[4*maxn];
void build(int v, int tl, int tr){
    if(tl == tr){
        bor[v] = niz[tl];
        return;
    }
    int mid = (tl + tr)/2;
    build(v*2, tl, mid);
    build(v*2+1, mid+1, tr);
    bor[v] = bor[v*2] + bor[v*2+1];
}
int get(int v, int tl, int tr, int poz){
    if(tl == tr)return bor[v];
    int mid = (tl + tr)/2;
    if(poz <= mid)return bor[v] + get(v*2, tl, mid, poz);
    else return bor[v] + get(v*2+1, mid+1, tr, poz);
}
void update(int v, int tl, int tr, int poz, int vre){
    if(tl == tr){
        bor[v] += vre;
        return;
    }
    int mid = (tl+tr)/2;
    if(poz <= mid)update(v*2,tl,mid,poz,vre);
    else update(v*2+1,mid+1,tr,poz,vre);
    bor[v] = bor[v*2] + bor[v*2+1];
}
int kveri(int v, int tl, int tr, int l, int r){
    if(tl > r || l > tr)return 0;
    if(l <= tl && r >= tr)return bor[v];
    int mid = (tl + tr)/2;
    return kveri(v*2,tl,mid,l,r) + kveri(v*2+1,mid+1,tr,l,r);
}



//Lazy propagate
ll bor[4*maxn];
ll lenj[4*maxn];
void build(int v, int tl, int tr){
    if(tl == tr){
        bor[v] = niz[tl];
        return;
    }
    int mid = (tl + tr) / 2;
    build(v*2,tl,mid);
    build(v*2+1,mid+1,tr);
    bor[v] = bor[v * 2] + bor[v * 2 + 1];
}
void propagate(int v, int tl, int tr){
    if(lenj[v]){
        bor[v] += lenj[v];
        if (tl != tr) {
            lenj[v * 2] += lenj[v];
            lenj[v * 2 + 1] += lenj[v];
        }
        lenj[v] = 0;
    }
}
void lazyupd(int v, int tl, int tr, int l, int r, ll vre){
    propagate(v, tl, tr);
    if(tl > tr || tl > r || tr < l)return;
    if(tl >= l && tr <= r) {
        bor[v] += vre;
        if (tl != tr) {
            lenj[v * 2] += vre;
            lenj[v * 2 + 1] += vre;
        }
        return;
    }
    int mid = (tl + tr) / 2;
    lazyupd(v*2,tl,mid,l,r,vre);
    lazyupd(v*2+1,mid+1,tr,l,r,vre);
    bor[v] = bor[v * 2] + bor[v * 2 + 1];
}
ll kveri(int v, int tl, int tr, int l, int r){
    propagate(v, tl, tr);
    if(tl > r || l > tr)return 0;
    if(l <= tl && r >= tr)return bor[v];
    int mid = (tl + tr)/2;
    return kveri(v*2,tl,mid,l,r) + kveri(v*2+1,mid+1,tr,l,r);
}



//Persistent 
int idx = 1;
ll bor[4*maxn];
int root[maxn], ls[maxn], rs[maxn];
void build(int v, int tl, int tr){
    if(tl == tr){
        bor[v] = niz[tl];
        return;
    }
    ls[v] = ++idx; rs[v] = ++idx;
    int mid = (tl + tr) / 2;
    build(ls[v], tl, mid);
    build(rs[v], mid+1, tr);
    bor[v] = bor[ls[v]] + bor[rs[v]];
}
void update(int v, int rv, int tl, int tr, int poz, int vre) {
    if(tl == tr){
        bor[v] = vre;
        return;
    }
    int mid = (tl + tr) / 2;
    if(poz <= mid){
        ls[v] = ++idx; rs[v] = rs[rv];
        update(ls[v],ls[rv],tl,mid,poz,vre);
    }else{
        ls[v] = ls[rv];rs[v] = ++idx;
        update(rs[v],rs[rv],mid+1,tr,poz,vre);
    }
    bor[v] = bor[ls[v]] + bor[rs[v]];
}
int kveri(int v, int tl, int tr, int l, int r){
    if(tl > r || l > tr)return 0;
    if(l <= tl && r >= tr)return bor[v];
    int mid = (tl + tr)/2;
    return kveri(ls[v],tl,mid,l,r) + kveri(rs[v],mid+1,tr,l,r);
}

// Za redom kveri - Persisent 
int idx = 0;
ll bor[50*maxn];
int root[50*maxn], ls[50*maxn], rs[50*maxn];
void update(int v, int rv, int tl, int tr, int poz, int vre) {
    if(tl == tr){
        bor[v] = bor[rv] + vre;
        return;
    }
    int mid = (tl + tr) / 2;
    if(poz <= mid){
        ls[v] = ++idx; rs[v] = rs[rv];
        update(ls[v],ls[rv],tl,mid,poz,vre);
    }else{
        ls[v] = ls[rv];rs[v] = ++idx;
        update(rs[v],rs[rv],mid+1,tr,poz,vre);
    }
    bor[v] = bor[ls[v]] + bor[rs[v]];
}
int kveri(int v, int tl, int tr, int l, int r){
    if(tl > r || l > tr)return 0;
    if(l <= tl && r >= tr)return bor[v];
    int mid = (tl + tr) / 2;
    return kveri(ls[v],tl,mid,l,r) + kveri(rs[v],mid+1,tr,l,r);
}



//Trie
int idx;
int lipa[maxn][26];
bool kraj[maxn];
void add(string x){
    int tr = 0;
    ff(i,0,x.size() - 1){
        if(!lipa[tr][x[i] - 'a'])lipa[tr][x[i] - 'a'] = ++idx;
        tr = lipa[tr][x[i] - 'a'];
        kraj[tr] = 1;
    }
    kraj[tr] = 1;
}
bool kve(string x){
    int tr = 0;
    ff(i,0,x.size() - 1){
        if(!lipa[tr][x[i] - 'a'])return 0;
        tr = lipa[tr][x[i] - 'a'];
    }
    return kraj[tr];
}

//Prefix trie
int idx;
int lipa[maxn][26];
void add(string x){
    int tr = 0;
    ff(i,0,x.size() - 1){
        if(!lipa[tr][x[i] - 'a'])lipa[tr][x[i] - 'a'] = ++idx;
        tr = lipa[tr][x[i] - 'a'];
    }
}
bool kve(string x){
    int tr = 0;
    ff(i,0,x.size() - 1){
        if(!lipa[tr][x[i] - 'a'])return 0;
        tr = lipa[tr][x[i] - 'a'];
    }
    return 1;
}


//Trie
int sle[maxn][26], brojac;
//int breza[maxn];
void dodaj(string x){
    int tren = 0;
    for(int i=0;i<x.size();i++){
        if(!sle[tren][x[i]-'a'])sle[tren][x[i]-'a'] = ++brojac;
        tren = sle[tren][x[i]-'a'];
        //breza[tren]++;
    }
}
void brisi(string x){
    int tren = 0;
    for(int i=0;i<x.size();i++){
        tren = sle[tren][x[i]-'a'];
        //breza[tren]--;
    }
}
bool rijesi(string x){
    int tren = 0;
    for(int i=0;i<x.size();i++){
        if(!sle[tren][x[i]-'a'])return 0;
        tren = sle[tren][x[i]-'a'];
    }
    return 1;
}

//Sliding window
deque<int> dq;
void add(int x){
    while(!dq.empty() && dq.back() < x)dq.pop_back();
    dq.push_back(x);
}
void del(int x){
    if(!dq.empty() && dq.front() == x)dq.pop_front();
}
int get(){
    if(dq.empty())return 0;
    return dq.front();
}


//RMG query - O(1)
ll lg[maxn];
ll sp[maxn][20];
void napravi(){
    for(int i=2;i<=maxn;i++)lg[i] = lg[i/2] + 1;
    for(int i=1;i<=n;i++)sp[i][0] = niz[i];
    for(int j=1;j<20;j++){
        for(int i=1;i+(1<<j)-1<= n;i++)
            sp[i][j] = min(sp[i][j-1], sp[i+(1<<(j-1))][j-1]);
    }
}
ll rmq(int l, int r){
    int x = lg[r-l+1];
    return min(sp[l][x], sp[r-(1<<x)+1][x]);
}



//TREAP - https://codeforces.com/problemset/problem/863/D
struct treap{
    int key, cnt, vre;
    ll pri;
    bool rev;
    treap *l, *r;
    treap(){ }
    treap(int key, ll pri, int vre):key(key), pri(pri), vre(vre), l(NULL), r(NULL), cnt(0), rev(0) { }
};
typedef treap* item;
int cnt(item v){
    return (v ? v->cnt : 0);
}
void upd_cnt (item v) {
    if(v)v->cnt = cnt(v->l) + cnt(v->r) + 1;
}
void push(item v){
    if(v && v->rev){
        v->rev = 0;
        swap(v->l, v->r);
        if(v->l)v->l->rev ^= 1;
        if(v->r)v->r->rev ^= 1;
    }
}
void split(item v, int key, item &tl, item &tr, int cer = 0){
    push(v);
    if(!v)return void(tl = tr = NULL);
    int tren = cer + cnt(v->l);
    if(key <= tren)split(v->l, key, tl, v->l, cer), tr = v;
    else split(v->r, key, v->r, tr, cer + 1 + cnt(v->l)), tl = v;
    upd_cnt(tl);upd_cnt(tr);
}
void mer(item &v, item tl, item tr) {
    push(tl);push(tr);
    if(!tl || !tr)v = (tl ? tl : tr);
    else if(tl->pri > tr->pri)mer(tl->r, tl->r, tr), v = tl;
    else mer(tr->l, tl, tr->l), v = tr;
    upd_cnt(v);
}
void ins(item &v, item it) {
    push(v);
    mer(v, v, it);
}
void okreni(item v, int l, int r) {
    item a, b, c;
    split(v, r + 1, v, c);
    split (v, l, a, b);
    b->rev ^= true;
    mer(v, a, b);
    mer(v, v, c);
}
void cyclic(item v, int l, int r){
    push(v);
    item a, b, c, d, e;
    split(v, r + 1, v, e);
    split(v, r, v, d);
    split(v, l + 1, v, c);
    split(v, l, a, b);
    mer(v, a, d);
    mer(v, v, b);
    mer(v, v, c);
    mer(v, v, e);
}
int value(item v, int x){
    push(v);
    if(!v)return -1;
    if(x == cnt(v->l))return v->vre;
    if(x < cnt(v->l))return value(v->l, x);
    else return value(v->r,x - cnt(v->l) - 1);
}
void print(item v){
    if(!v)return;
    print(v->l);
    cout << v->vre << endl;
    print(v->r);
}

// Ordered set
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;

// WARNING: functions as a set (doesn't allow duplicates); insert pairs instead if duplicates are needed.
// Consider using splay_tree instead if constant factor is an issue (e.g., log^2 solutions), especially with duplicates.
template<typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
