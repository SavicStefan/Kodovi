// Convex hull optimizacija (valjda)
/*struct Line{
	ll n,k;
	int cnt;
	Line(){}
	Line(ll a,ll b,int c):n(a),k(b),cnt(c){}
	ll Get(ll x){return x*k+n;}
};
int sec(Line a,Line b){
	ll p=a.n-b.n;
	ll q=b.k-a.k;
	if(q<0)p=-p,q=-q;
	if(p<0)return p/q;
	else return (p+q-1)/q;
}
vector<Line> hull;
void AddLine(Line l){
	int sz=hull.size();
	while(sz>1 && sec(hull[sz-2],hull[sz-1])>sec(hull[sz-1],l)){
		sz--;
		hull.pop_back();
	}
	hull.pb(l);sz++;
}
pair<ll,int> Get(ll x){
	int bot=1,top=(int)hull.size()-1,mid,ans=0;
	while(top>=bot){
		int mid=bot+top>>1;
		if(hull[mid-1].Get(x)<hull[mid].Get(x))ans=mid,bot=mid+1;
		else top=mid-1;
	}
	return {hull[ans].Get(x),hull[ans].cnt};
}
ll dp[N];
int cnt[N];
void Push(int L){
	AddLine(Line(dp[L]+sum[L]*(L+1)-pre[L],(L+1),cnt[L]));
}
pair<ll,int> Solve(int C,int n){
	hull.clear();
	dp[0]=0;
	cnt[0]=0;
	Push(0);
	for(int i=1;i<=n;i++){
		pair<ll,int> now=Get(-sum[i]);
		dp[i]=now.first+pre[i]+C;
		cnt[i]=now.second+1;
		Push(i);
	}
	return {dp[n],cnt[n]};
}*/


// Temp
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <bits/stdc++.h>

#define fi first
#define se second
#define pb push_back
#define sz(a) (int)a.size()
#define all(a) a.begin(), a.end()
#define ff(i,a,b) for(int i=a;i<=b;i++)
#define fb(i,b,a) for(int i=b;i>=a;i--)

using namespace std;
using namespace __gnu_pbds;
typedef long long ll;
typedef pair<ll,ll> pii;
const int maxn = 200005;
const ll inf = 1e18 + 5;

template<typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

// os.order_of_key(k) the number of elements in the os less than k
// *os.find_by_order(k)  print the k-th smallest number in os(0-based)

int main()
{
    ios::sync_with_stdio(false);
    cout.tie(nullptr);
    cin.tie(nullptr);

    return 0;
}
/**



// probati bojenje sahovski ili slicno

**/
