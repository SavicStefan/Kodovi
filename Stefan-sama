// Convex hull optimizacija (valjda)
/*struct Line{
	ll n,k;
	int cnt;
	Line(){}
	Line(ll a,ll b,int c):n(a),k(b),cnt(c){}
	ll Get(ll x){return x*k+n;}
};
int sec(Line a,Line b){
	ll p=a.n-b.n;
	ll q=b.k-a.k;
	if(q<0)p=-p,q=-q;
	if(p<0)return p/q;
	else return (p+q-1)/q;
}
vector<Line> hull;
void AddLine(Line l){
	int sz=hull.size();
	while(sz>1 && sec(hull[sz-2],hull[sz-1])>sec(hull[sz-1],l)){
		sz--;
		hull.pop_back();
	}
	hull.pb(l);sz++;
}
pair<ll,int> Get(ll x){
	int bot=1,top=(int)hull.size()-1,mid,ans=0;
	while(top>=bot){
		int mid=bot+top>>1;
		if(hull[mid-1].Get(x)<hull[mid].Get(x))ans=mid,bot=mid+1;
		else top=mid-1;
	}
	return {hull[ans].Get(x),hull[ans].cnt};
}
ll dp[N];
int cnt[N];
void Push(int L){
	AddLine(Line(dp[L]+sum[L]*(L+1)-pre[L],(L+1),cnt[L]));
}
pair<ll,int> Solve(int C,int n){
	hull.clear();
	dp[0]=0;
	cnt[0]=0;
	Push(0);
	for(int i=1;i<=n;i++){
		pair<ll,int> now=Get(-sum[i]);
		dp[i]=now.first+pre[i]+C;
		cnt[i]=now.second+1;
		Push(i);
	}
	return {dp[n],cnt[n]};
}*/

// tourist treap and splay: https://codeforces.com/contest/847/status/D?friends=on
//geometry template: https://codeforces.com/contest/280/submission/3275722


// Temp
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <bits/stdc++.h>

#define fi first
#define se second
#define pb push_back
#define sz(a) (int)a.size()
#define all(a) a.begin(), a.end()
#define ff(i,a,b) for(int i=a;i<=b;i++)
#define fb(i,b,a) for(int i=b;i>=a;i--)

using namespace std;
using namespace __gnu_pbds;
typedef long long ll;
typedef pair<ll,ll> pii;
const int maxn = 200005;
const ll inf = 1e18 + 5;

template<typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

// os.order_of_key(k) the number of elements in the os less than k
// *os.find_by_order(k)  print the k-th smallest number in os(0-based)

int main()
{
    ios::sync_with_stdio(false);
    cout.tie(nullptr);
    cin.tie(nullptr);

    return 0;
}
/**



// probati bojenje sahovski ili slicno

**/

// Number theory 
namespace number_theory {
	ll gcd(ll x, ll y) {
	  if (x == 0) return y;
	  if (y == 0) return x;
	  return gcd(y, x % y);
	}
	bool isprime(ll n) { 
	  if (n <= 1) return false; 
	  if (n <= 3) return true; 
	  
	  if (n % 2 == 0 || n % 3 == 0) return false; 
	  
	  for (ll i = 5; i * i <= n; i += 6) 
		if (n % i == 0 || n % (i+2) == 0) 
		  return false; 
	  
	  return true; 
	} 
	 
	bool prime[15000105]; 
	void sieve(int n) { 
	  for (ll i = 0; i <= n; i++) prime[i] = 1;
	  for (ll p = 2; p * p <= n; p++) { 
		if (prime[p] == true) { 
		  for (ll i = p * p; i <= n; i += p) 
			prime[i] = false; 
		} 
	  } 
	  prime[1] = prime[0] = 0;
	} 
	 
	vector<ll> primelist;
	bool __primes_generated__ = 0;
	 
	void genprimes(int n) {
	  __primes_generated__ = 1;
	  sieve(n + 1);
	  for (ll i = 2; i <= n; i++) if (prime[i]) primelist.push_back(i);
	}
	 
	vector<ll> factors(ll n) {
	  if (!__primes_generated__) {
		cerr << "Call genprimes you dope" << endl;
		exit(1);
	  }
	  vector<ll> facs;
	 
	  for (ll i = 0; primelist[i] * primelist[i] <= n && i < primelist.size(); i++) {
		if (n % primelist[i] == 0) {
		  while (n % primelist[i] == 0) {
			n /= primelist[i];
			facs.push_back(primelist[i]);
		  }
		}
	  }
	  if (n > 1) {
		facs.push_back(n);
	  }
	  sort(facs.begin(), facs.end());
	  return facs;
	}
	
	vector<ll> getdivs(ll n) {
    vector<ll> divs;
    for (ll i = 1; i * i <= n; i++) {
      if (n % i == 0) {
        divs.push_back(i);
        divs.push_back(n / i);
      }
    }
 
    getunique(divs);
    return divs;
  }
}
 
using namespace number_theory;
